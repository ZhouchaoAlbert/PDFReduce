#include "UtilImage.h"
#include "ximage.h"


LPTSTR Util::Image::FindExtension(LPCTSTR szExeName)
{
	int nLen = _tcslen(szExeName);
	int i;
	for (i = nLen - 1; i >= 0; i--){
		if (szExeName[i] == '.'){
			return (TCHAR*)(szExeName + i + 1);
		}
	}
	return (LPTSTR)(szExeName + nLen);
}


void DoSplitTiff(LPCTSTR strImagePath, LPCTSTR szSavePath)
{
	CxImage image;
	int nFrameCnt = 0;

	//加载图片,给image结构赋值
	image.Load(strImagePath, CXIMAGE_FORMAT_TIF);

	//计算一张tiff图片是由多少张图片合成的
	nFrameCnt = image.GetNumFrames();

	//每次循环都加载1张tiff图片，并保存到m_pImageData中
	for (int nIndex = 0; nIndex < nFrameCnt; nIndex++)
	{
		image.SetFrame(nIndex);
		image.Load(strImagePath, CXIMAGE_FORMAT_TIF);

		//m_pImageData->Copy(image);

		//每张图片保存的路径
		CString strSavePath(szSavePath);
		if (strSavePath.Right(1) == "\\")
		{
			strSavePath.Format(_T("%d%s"), nIndex, _T(".tif"));
		}
		else
		{
			strSavePath.Format(_T("\\%d%s"), nIndex, _T(".tif"));
		}

		//保存
		image.Save(strSavePath, CXIMAGE_FORMAT_TIF);
	}
}
BOOL Util::Image::ConvertType(LPCTSTR szImagePathIn, LPCTSTR szImagePathOut, UINT32 bQuality/* = 50*/)
{
	//1.判断类型 
	TCHAR* szExtIn = FindExtension(szImagePathIn);
	_tcslwr(szExtIn);
	INT32 nTypeIn = CxImage::GetTypeIdFromName(szExtIn);
	if (nTypeIn == CXIMAGE_FORMAT_UNKNOWN) {
		MessageBox(NULL, _T("输入的图片格式不对,请重新输入!"), _T("提示"), MB_OK);
		return FALSE;
	}

	TCHAR* szExtOut = FindExtension(szImagePathOut);
	_tcslwr(szExtOut);
	INT32 nTypeOut = CxImage::GetTypeIdFromName(szExtOut);
	if (nTypeOut == CXIMAGE_FORMAT_UNKNOWN) {
		MessageBox(NULL, _T("输出的图片格式不对,请重新输入!"), _T("提示"), MB_OK);
		return FALSE;
	}

	//2对输入图片的大小分别做判断

	if (nTypeIn == CXIMAGE_FORMAT_TIF)
	{
	
	}

	//3图片转换
	CxImage image;

	image.Load((const TCHAR*)szImagePathIn, nTypeIn);
	
	if (!image.IsValid()) 
	{
		MessageBox(NULL, _T("转换失败"), _T("提示"), MB_OK);
		return FALSE;
	}
	
	image.SetJpegQuality(bQuality);
	image.Save((const TCHAR*)szImagePathOut, nTypeOut);
	return TRUE;
}
